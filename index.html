<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Snake</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #0f172a;
            overflow: hidden; /* Prevent scrolling */
            touch-action: none; /* Prevent browser gestures */
        }

        /* Scanline effect */
        .scanlines {
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.1) 50%,
                rgba(0,0,0,0.1)
            );
            background-size: 100% 4px;
            position: absolute;
            top: 0; 
            left: 0;
            right: 0; 
            bottom: 0;
            pointer-events: none;
            z-index: 10;
        }

        /* Glow effects */
        canvas {
            box-shadow: 0 0 20px rgba(34, 197, 94, 0.2);
            border: 2px solid #334155;
        }

        .text-neon-green {
            color: #4ade80;
            text-shadow: 0 0 10px rgba(74, 222, 128, 0.5);
        }

        .text-neon-red {
            color: #f87171;
            text-shadow: 0 0 10px rgba(248, 113, 113, 0.5);
        }
        
        .modal {
            transition: opacity 0.3s ease-in-out;
        }
    </style>
</head>
<body class="h-screen w-screen flex flex-col items-center justify-center relative select-none">

    <div class="scanlines"></div>

    <!-- UI Overlay -->
    <div class="absolute top-4 w-full px-8 flex justify-between z-20 text-sm md:text-base">
        <div class="text-slate-400">SCORE: <span id="scoreDisplay" class="text-neon-green">0</span></div>
        <div class="text-slate-400">HIGH: <span id="highScoreDisplay" class="text-neon-green">0</span></div>
    </div>

    <!-- Game Container -->
    <div class="relative z-10 p-4 w-full h-full flex items-center justify-center">
        <canvas id="gameCanvas" class="bg-slate-900 rounded-lg"></canvas>
    </div>

    <!-- Start / Game Over Modal -->
    <div id="gameModal" class="absolute inset-0 z-30 flex items-center justify-center bg-slate-900/80 backdrop-blur-sm">
        <div class="text-center p-8 bg-slate-800 border-2 border-slate-600 rounded-xl shadow-2xl max-w-sm mx-4 transform transition-all">
            <h1 id="modalTitle" class="text-4xl mb-6 text-neon-green tracking-widest">SNAKE</h1>
            <p id="modalScore" class="hidden text-slate-300 mb-4 text-sm">FINAL SCORE: <span class="text-white">0</span></p>
            <p class="text-slate-400 text-xs mb-8 leading-6">
                <span class="hidden md:inline">USE ARROW KEYS</span>
                <span class="md:hidden">SWIPE TO MOVE</span>
                <br>TO EAT THE <span class="text-neon-red">‚óè</span>
            </p>
            <button id="startBtn" class="px-8 py-3 bg-green-600 hover:bg-green-500 text-white rounded text-sm transition-colors duration-200 shadow-[0_0_15px_rgba(22,163,74,0.5)]">
                START GAME
            </button>
        </div>
    </div>

    <!-- Mobile Controls Hint (Visible briefly on load on mobile) -->
    <div id="mobileHint" class="md:hidden absolute bottom-10 text-slate-500 text-xs opacity-0 transition-opacity duration-1000 z-0">
        Swipe to change direction
    </div>

    <script>
        // Configuration
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const highScoreDisplay = document.getElementById('highScoreDisplay');
        const gameModal = document.getElementById('gameModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalScore = document.getElementById('modalScore');
        const startBtn = document.getElementById('startBtn');

        // Game State
        let gridSize = 20; // Size of one square
        let tileCountX = 20;
        let tileCountY = 20;
        let velocity = { x: 0, y: 0 };
        let snake = [];
        let food = { x: 15, y: 15 };
        let score = 0;
        let highScore = localStorage.getItem('snakeHighScore') || 0;
        let gameLoop;
        let isGameRunning = false;
        let speed = 7; // Lower is faster (logic frames per render) but we use time delta for smoothness
        let lastRenderTime = 0;
        let snakeSpeed = 10; // Moves per second approximately
        
        // Colors
        const COLOR_BG = '#0f172a'; // slate-900
        const COLOR_SNAKE_HEAD = '#4ade80'; // green-400
        const COLOR_SNAKE_BODY = '#22c55e'; // green-500
        const COLOR_FOOD = '#f87171'; // red-400
        const COLOR_GRID = '#1e293b'; // slate-800

        highScoreDisplay.innerText = highScore;

        // Resize Handling
        function resizeCanvas() {
            // Determine max available width/height minus padding
            const container = canvas.parentElement;
            const maxWidth = container.clientWidth - 32; // padding
            const maxHeight = container.clientHeight - 32;

            // Calculate grid dimensions based on aspect ratio
            // We want roughly square tiles, but fit the screen
            const cols = Math.floor(maxWidth / gridSize);
            const rows = Math.floor(maxHeight / gridSize);

            // Cap the grid size to keep gameplay sane
            tileCountX = Math.min(cols, 40); 
            tileCountY = Math.min(rows, 40);

            canvas.width = tileCountX * gridSize;
            canvas.height = tileCountY * gridSize;
        }

        window.addEventListener('resize', () => {
            resizeCanvas();
            if(!isGameRunning && snake.length > 0) {
                draw(); // Redraw static game if resized while paused/over
            }
        });
        
        // Init
        resizeCanvas();

        function startGame() {
            isGameRunning = true;
            gameModal.style.opacity = '0';
            setTimeout(() => {
                gameModal.classList.add('hidden');
            }, 300);
            
            // Reset Game Logic
            snake = [
                { x: 10, y: 10 }, // Head
                { x: 10, y: 11 },
                { x: 10, y: 12 }
            ];
            velocity = { x: 0, y: -1 }; // Move up initially
            score = 0;
            scoreDisplay.innerText = score;
            placeFood();
            
            window.requestAnimationFrame(main);
        }

        function gameOver() {
            isGameRunning = false;
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('snakeHighScore', highScore);
                highScoreDisplay.innerText = highScore;
            }
            
            modalTitle.innerText = "GAME OVER";
            modalTitle.classList.replace('text-neon-green', 'text-neon-red');
            modalScore.querySelector('span').innerText = score;
            modalScore.classList.remove('hidden');
            startBtn.innerText = "TRY AGAIN";
            
            gameModal.classList.remove('hidden');
            // Small delay to allow fade in
            requestAnimationFrame(() => {
                gameModal.style.opacity = '1';
            });
        }

        function main(currentTime) {
            if (!isGameRunning) return;

            window.requestAnimationFrame(main);

            const secondsSinceLastRender = (currentTime - lastRenderTime) / 1000;
            
            // Control game speed
            if (secondsSinceLastRender < 1 / snakeSpeed) return;
            
            lastRenderTime = currentTime;

            update();
            draw();
        }

        function update() {
            // Calculate new head position
            const head = { x: snake[0].x + velocity.x, y: snake[0].y + velocity.y };

            // Wall Collision
            if (head.x < 0 || head.x >= tileCountX || head.y < 0 || head.y >= tileCountY) {
                return gameOver();
            }

            // Self Collision
            for (let i = 0; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    return gameOver();
                }
            }

            snake.unshift(head); // Add new head

            // Check Food Collision
            if (head.x === food.x && head.y === food.y) {
                score += 10;
                scoreDisplay.innerText = score;
                // Increase speed slightly every 50 points
                if (score % 50 === 0) snakeSpeed += 0.5;
                placeFood();
                // Don't pop tail, so snake grows
            } else {
                snake.pop(); // Remove tail
            }
        }

        function placeFood() {
            let validPosition = false;
            while (!validPosition) {
                food.x = Math.floor(Math.random() * tileCountX);
                food.y = Math.floor(Math.random() * tileCountY);

                validPosition = true;
                // Check if food spawned on snake
                for (let part of snake) {
                    if (part.x === food.x && part.y === food.y) {
                        validPosition = false;
                        break;
                    }
                }
            }
        }

        function draw() {
            // Clear screen
            ctx.fillStyle = COLOR_BG;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw Grid (Optional, makes it look retro)
            ctx.strokeStyle = COLOR_GRID;
            ctx.lineWidth = 1;
            for(let x=0; x<=tileCountX; x++) {
                ctx.beginPath();
                ctx.moveTo(x * gridSize, 0);
                ctx.lineTo(x * gridSize, canvas.height);
                ctx.stroke();
            }
            for(let y=0; y<=tileCountY; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * gridSize);
                ctx.lineTo(canvas.width, y * gridSize);
                ctx.stroke();
            }

            // Draw Food (Glowing Circle)
            const cx = food.x * gridSize + gridSize/2;
            const cy = food.y * gridSize + gridSize/2;
            const radius = gridSize/2 - 2;
            
            ctx.shadowColor = COLOR_FOOD;
            ctx.shadowBlur = 15;
            ctx.fillStyle = COLOR_FOOD;
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.shadowBlur = 0; // Reset shadow for other elements

            // Draw Snake
            snake.forEach((part, index) => {
                const px = part.x * gridSize;
                const py = part.y * gridSize;
                
                // Style
                ctx.fillStyle = index === 0 ? COLOR_SNAKE_HEAD : COLOR_SNAKE_BODY;
                
                // Slight glow for head
                if(index === 0) {
                    ctx.shadowColor = COLOR_SNAKE_HEAD;
                    ctx.shadowBlur = 10;
                } else {
                    ctx.shadowBlur = 0;
                }

                // Draw rounded rectangle for body parts
                ctx.fillRect(px + 1, py + 1, gridSize - 2, gridSize - 2);
            });
            
            ctx.shadowBlur = 0; // Reset
        }

        // Input Handling
        // -----------------------
        
        // Keyboard
        document.addEventListener('keydown', (e) => {
            if (!isGameRunning) return;
            
            switch (e.key) {
                case 'ArrowUp':
                    if (velocity.y === 1) break; // Prevent reversing
                    velocity = { x: 0, y: -1 };
                    break;
                case 'ArrowDown':
                    if (velocity.y === -1) break;
                    velocity = { x: 0, y: 1 };
                    break;
                case 'ArrowLeft':
                    if (velocity.x === 1) break;
                    velocity = { x: -1, y: 0 };
                    break;
                case 'ArrowRight':
                    if (velocity.x === -1) break;
                    velocity = { x: 1, y: 0 };
                    break;
            }
        });

        // Touch (Swipe)
        let touchStartX = 0;
        let touchStartY = 0;

        document.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, {passive: false});

        document.addEventListener('touchmove', (e) => {
             e.preventDefault(); // Prevent scrolling while playing
        }, {passive: false});

        document.addEventListener('touchend', (e) => {
            if (!isGameRunning) return;

            let touchEndX = e.changedTouches[0].screenX;
            let touchEndY = e.changedTouches[0].screenY;
            
            handleSwipe(touchStartX, touchStartY, touchEndX, touchEndY);
        }, {passive: false});

        function handleSwipe(sx, sy, ex, ey) {
            let dx = ex - sx;
            let dy = ey - sy;
            
            if (Math.abs(dx) > Math.abs(dy)) {
                // Horizontal
                if (Math.abs(dx) > 20) { // Threshold
                    if (dx > 0) {
                        if (velocity.x !== -1) velocity = { x: 1, y: 0 }; // Right
                    } else {
                        if (velocity.x !== 1) velocity = { x: -1, y: 0 }; // Left
                    }
                }
            } else {
                // Vertical
                if (Math.abs(dy) > 20) {
                    if (dy > 0) {
                        if (velocity.y !== -1) velocity = { x: 0, y: 1 }; // Down
                    } else {
                        if (velocity.y !== 1) velocity = { x: 0, y: -1 }; // Up
                    }
                }
            }
        }

        startBtn.addEventListener('click', startGame);

        // Mobile hint fade in
        if ('ontouchstart' in window) {
            setTimeout(() => {
                const hint = document.getElementById('mobileHint');
                hint.classList.replace('opacity-0', 'opacity-100');
                setTimeout(() => hint.classList.replace('opacity-100', 'opacity-0'), 4000);
            }, 1000);
        }

    </script>
</body>
</html>
